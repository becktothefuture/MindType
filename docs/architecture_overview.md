# MindType Architecture Overview

This document expands on the engineering spec and explains how the parts of the tool fit together. It is designed to provide a mental picture of the final system before implementation begins.

## High-Level Pipeline

1. **Keystroke Handling** â€“ Every printable key resets the pause timer. This keeps the system passive until the user naturally pauses.
2. **Fragment Extraction** â€“ Once idle time elapses, the extractor looks back for a sentence boundary within 250 characters. This fragment plus ~100 characters of context is packaged for correction.
3. **LLM Correction** â€“ A streaming call is made to the language model. The initial version uses GPTâ€‘3.5 via HTTPS; the longâ€‘term goal is an onâ€‘device Core ML model. Prompting focuses purely on grammar and spelling fixes.
4. **Incremental Diff and Merge** â€“ The output stream is patched into the existing buffer using diffâ€‘matchâ€‘patch. Patches are small and applied incrementally so the user sees text update as tokens arrive.
5. **Injection** â€“ The corrected fragment replaces the original text in place, preserving formatting, undo stack integrity and cursor position.

```
key press â†’ [PauseTimer] â†’ idle
           â†“                    â†˜
    [FragmentExtractor]   [Abort stream if new key]
           â†“                    â†˜
    [LLMClient] â†’ token stream â†’ [MergeEngine] â†’ patches â†’ [Injector]
```

The arrows illustrate how a typing pause triggers the fragment extractor. Streaming can be aborted if a new key arrives mid-flight. This diagram mirrors both the browser and macOS implementations.

This pipeline is now **implemented once in Rust** (`crates/core-rs`) and surfaced to each platform via generated bindings:

- **Web** â†’ WebAssembly package `@mindtype/core` consumed by React hooks.
- **macOS** â†’ Static library `libmindtype.a` + Swift module created with `cbindgen`.

Maintaining one canonical codebase removes divergence between TypeScript and Swift implementations that were planned in the earlier draft.

## Module Breakdown

### crates/core-rs ðŸ”¹

The Rust crate contains the reference implementations of the pause timer, fragment extractor, merge engine and streaming LLM client. The TS and Swift layers import these functions rather than re-implementing them.

### bindings/wasm ðŸ”¹

Generated by `wasm-bindgen`, this npm package exposes the Rust API to TypeScript with zero-copy string sharing where supported.

### bindings/swift ðŸ”¹

A `module.modulemap` and C header expose the same API to Swift/Obj-C. Build scripts in `mac/` link `libmindtype.a` automatically.

### web-demo

React components wrap the core logic and provide a simple typing playground. It demonstrates streaming corrections in real time and captures emails for the beta list.

### mac/

Native macOS layer written in Swift/SwiftUI. It links to the **same Rust core** via FFI; no re-implementation required.

## Rationale

- **One Pipeline** â€“ By designing a single languageâ€‘agnostic algorithm we avoid divergence between platforms and ensure consistent user experience.
- **Streaming** â€“ Token streaming keeps latency perceptibly low and makes the tool feel alive. This also reduces the risk of large diff conflicts.
- **Local Model Path** â€“ Shipping an onâ€‘device model guarantees privacy and offline usage. The spec outlines the conversion of a small BART model into Core ML as a first milestone.

Further details on specific components can be found in the accompanying documents.

## Next Steps

1. Publish the `@mindtype/core` WASM package to npm once CI is green.
2. Finish FFI bindings in the mac app and verify parity with the Playwrightâ€‰/â€‰XCUITest suite.
3. Run performance tuning and finalise Core ML model conversion.

This overview aims to answer **why** each component exists before diving into code. The shared pipeline enforces consistent behaviour, while individual modules stay small enough to be unit tested in isolation. Developers should be able to run the core on its own (node-based tests) or through the demo/mac front-ends without rewriting logic.

The additional documents referenced in the main spec â€“ including [core_details.md](core_details.md), [web_demo_details.md](web_demo_details.md) and [mac_app_details.md](mac_app_details.md) â€“ provide step-by-step guidance on implementation choices.
