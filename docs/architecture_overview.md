# MindType Architecture Overview

This document expands on the engineering spec and explains how the parts of the tool fit together. It is designed to provide a mental picture of the final system before implementation begins.

## High-Level Pipeline

1. **Keystroke Handling** â€“ Every printable key resets the pause timer and advances a typing tick (~60â€“90 ms cadence) for streamed diffusion.
2. **Fragment Extraction** â€“ The active fragment is the sentence behind the caret within 250 characters (Â± context). Diffusion operates within a trailing band of ~3â€“8 words.
3. **LLM/Rules Correction** â€“ Wordâ€‘sized chunks are validated and corrected in the trailing band while typing continues. Longâ€‘term goal: onâ€‘device Core ML; stub/remote acceptable for demos.
4. **Incremental Diff and Merge** â€“ Patches are caretâ€‘safe and wordâ€‘bounded. During typing, a frontier advances toward the caret; on pause (~500 ms), diffusion catches up.
5. **Injection** â€“ Apply in place, preserving formatting, undo grouping, and cursor position. Visuals: subtle shimmer band; reducedâ€‘motion fallback.

```
key press â†’ [PauseTimer] â†’ idle
           â†“                    â†˜
    [FragmentExtractor]   [Abort stream if new key]
           â†“                    â†˜
   [LLMClient] â†’ word stream â†’ [MergeEngine] â†’ patches â†’ [Injector]
```

The arrows illustrate how a typing pause triggers the fragment extractor. Streaming can be aborted if a new key arrives mid-flight. This diagram mirrors both the browser and macOS implementations.

This pipeline is **implemented in Rust** (`crates/core-rs`) and surfaced to each platform via generated bindings. A small TypeScript `DiffusionController` orchestrates streaming ticks and visuals while delegating heavy lifting to the core:

- **Web** â†’ WebAssembly package `@mindtype/core` consumed by React hooks.
- **macOS** â†’ Static library `libmindtype.a` + Swift module created with `cbindgen`.

Maintaining one canonical codebase removes divergence between TypeScript and Swift implementations that were planned in the earlier draft.

## Module Breakdown

### crates/core-rs ðŸ”¹

The Rust crate contains the reference implementations of the pause timer, fragment extractor, merge engine and streaming LLM client. The TS and Swift layers import these functions rather than re-implementing them.

### bindings/wasm ðŸ”¹

Generated by `wasm-bindgen`, this npm package exposes the Rust API to TypeScript with zero-copy string sharing where supported.

### bindings/swift ðŸ”¹

A `module.modulemap` and C header expose the same API to Swift/Obj-C. Build scripts in `mac/` link `libmindtype.a` automatically.

### web-demo

React components wrap the core logic and provide a simple typing playground. It demonstrates streaming corrections in real time and captures emails for the beta list.

### mac/

Native macOS layer written in Swift/SwiftUI. It links to the **same Rust core** via FFI; no re-implementation required.

## Rationale

- **One Pipeline** â€“ By designing a single languageâ€‘agnostic algorithm we avoid divergence between platforms and ensure consistent user experience.
- **Streaming** â€“ Token streaming keeps latency perceptibly low and makes the tool feel alive. This also reduces the risk of large diff conflicts.
- **Local Model Path** â€“ Shipping an onâ€‘device model guarantees privacy and offline usage. The spec outlines the conversion of a small BART model into Core ML as a first milestone.

Further details on specific components can be found in the accompanying documents.

## Next Steps

1. Publish the `@mindtype/core` WASM package to npm once CI is green.
2. Finish FFI bindings in the mac app and verify parity with the Playwrightâ€‰/â€‰XCUITest suite.
3. Run performance tuning and finalise Core ML model conversion.

This overview aims to answer **why** each component exists before diving into code. The shared pipeline enforces consistent behaviour, while individual modules stay small enough to be unit tested in isolation. Developers should be able to run the core on its own (node-based tests) or through the demo/mac front-ends without rewriting logic.

The additional documents referenced in the main spec â€“ including [web_demo_details.md](web_demo_details.md) and [mac_app_details.md](mac_app_details.md) â€“ provide step-by-step guidance on implementation choices.
